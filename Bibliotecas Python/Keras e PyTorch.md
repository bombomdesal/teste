Aqui está uma tabela com as principais funções, classes e métodos da **Keras**, que é uma API de alto nível em Python para construir e treinar redes neurais, integrada ao TensorFlow:

| **Categoria**              | **Função/Classe/Método** | **Descrição**                                                                                               | **Exemplo de Uso**                                                                 |
|----------------------------|-------------------------|--------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------|
| **Construção de Modelos**   | `keras.Sequential()`    | Cria um modelo sequencial, onde as camadas são empilhadas linearmente.                                        | `model = keras.Sequential()`                                                       |
|                            | `keras.Model()`         | Cria um modelo mais flexível, permitindo arquiteturas complexas.                                             | `class MyModel(keras.Model):`<br>`def __init__(self): ...`                         |
|                            | `model.compile()`       | Configura o modelo para o treinamento, especificando otimizador, função de perda e métricas.                 | `model.compile(optimizer='adam', loss='sparse_categorical_crossentropy')`          |
|                            | `model.fit()`           | Treina o modelo nos dados fornecidos por um número especificado de épocas.                                   | `model.fit(X_train, y_train, epochs=10)`                                           |
|                            | `model.evaluate()`      | Avalia o desempenho do modelo nos dados de teste.                                                            | `model.evaluate(X_test, y_test)`                                                   |
|                            | `model.predict()`       | Gera previsões para novos dados de entrada.                                                                  | `predictions = model.predict(new_data)`                                            |
|                            | `model.summary()`       | Exibe a arquitetura do modelo, mostrando as camadas, tipos de dados e parâmetros.                            | `model.summary()`                                                                  |
| **Camadas**                 | `keras.layers.Dense()`  | Adiciona uma camada densa (fully connected), frequentemente usada em redes neurais profundas.                | `keras.layers.Dense(64, activation='relu')`                                        |
|                            | `keras.layers.Conv2D()` | Adiciona uma camada convolucional 2D, essencial em redes neurais convolucionais (CNNs).                      | `keras.layers.Conv2D(32, (3, 3), activation='relu')`                               |
|                            | `keras.layers.MaxPooling2D()` | Adiciona uma camada de pooling máximo, usada para redução de dimensionalidade em CNNs.                  | `keras.layers.MaxPooling2D(pool_size=(2, 2))`                                      |
|                            | `keras.layers.Dropout()` | Aplica a regularização Dropout para prevenir overfitting durante o treinamento.                              | `keras.layers.Dropout(0.5)`                                                        |
|                            | `keras.layers.LSTM()`   | Adiciona uma camada LSTM (Long Short-Term Memory), usada em redes neurais recorrentes para sequências de dados. | `keras.layers.LSTM(128)`                                                         |
|                            | `keras.layers.Embedding()` | Adiciona uma camada de embedding, usada para transformar entradas categóricas em vetores de baixa dimensão. | `keras.layers.Embedding(input_dim=1000, output_dim=64)`                           |
| **Funções de Perda**        | `keras.losses.MeanSquaredError()` | Calcula o erro quadrático médio, usado frequentemente em problemas de regressão.                    | `loss = keras.losses.MeanSquaredError()`                                           |
|                            | `keras.losses.SparseCategoricalCrossentropy()` | Calcula a entropia cruzada categórica esparsa, comum em classificações de múltiplas classes. | `loss = keras.losses.SparseCategoricalCrossentropy()`                              |
| **Otimização**              | `keras.optimizers.Adam()` | Implementa o otimizador Adam, amplamente usado em deep learning.                                             | `optimizer = keras.optimizers.Adam(learning_rate=0.001)`                           |
|                            | `keras.optimizers.SGD()` | Implementa o otimizador Stochastic Gradient Descent (SGD).                                                    | `optimizer = keras.optimizers.SGD(learning_rate=0.01)`                             |
| **Callback**                | `keras.callbacks.ModelCheckpoint()` | Salva o modelo durante o treinamento quando uma métrica específica melhora.                               | `keras.callbacks.ModelCheckpoint('melhor_modelo.h5', save_best_only=True)`         |
|                            | `keras.callbacks.EarlyStopping()` | Interrompe o treinamento quando uma métrica parar de melhorar.                                              | `keras.callbacks.EarlyStopping(patience=3)`                                        |
|                            | `keras.callbacks.TensorBoard()` | Permite a visualização do processo de treinamento com TensorBoard.                                           | `keras.callbacks.TensorBoard(log_dir='./logs')`                                    |
| **Pré-processamento de Dados** | `keras.preprocessing.image.ImageDataGenerator()` | Gera batches de dados de imagem com aumentos em tempo real, útil para aumentar artificialmente o dataset. | `datagen = keras.preprocessing.image.ImageDataGenerator(rotation_range=40, ...)`  |
|                            | `keras.preprocessing.sequence.pad_sequences()` | Ajusta as sequências a um comprimento comum, preenchendo ou truncando conforme necessário.                  | `padded_seq = keras.preprocessing.sequence.pad_sequences(sequences, maxlen=100)`   |
| **Transfer Learning**       | `keras.applications`    | Conjunto de modelos pré-treinados disponíveis para transferência de aprendizado (ex: VGG16, ResNet).        | `model = keras.applications.ResNet50(weights='imagenet', include_top=False)`       |
| **Salvamento/Carregamento** | `model.save()`         | Salva o modelo completo (arquitetura e pesos).                                                              | `model.save('meu_modelo.h5')`                                                      |
|                            | `keras.models.load_model()` | Carrega um modelo salvo anteriormente.                                                                  | `model = keras.models.load_model('meu_modelo.h5')`                                 |
| **Visualização de Modelos** | `keras.utils.plot_model()` | Gera um diagrama visual da arquitetura do modelo.                                                           | `keras.utils.plot_model(model, to_file='modelo.png', show_shapes=True)`            |
| **Outros**                  | `keras.backend`        | API de baixo nível para operações tensoriais, útil para customização profunda em Keras.                     | `keras.backend.clear_session()`                                                    |

Essa tabela cobre as principais funcionalidades da **Keras** para construção, treinamento e ajuste de modelos de redes neurais, especialmente em um ambiente integrado ao TensorFlow. Keras é conhecida por sua simplicidade e facilidade de uso, permitindo a construção de modelos complexos com poucas linhas de código.


Aqui está uma tabela com as principais funções, classes e métodos do **PyTorch**, uma das principais bibliotecas para criação e treinamento de redes neurais e aprendizado de máquina:

| **Categoria**              | **Função/Classe/Método** | **Descrição**                                                                                             | **Exemplo de Uso**                                                                 |
|----------------------------|-------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------|
| **Tensores**                | `torch.tensor()`        | Cria um tensor a partir de dados, semelhante ao numpy array.                                               | `a = torch.tensor([1, 2, 3])`                                                      |
|                            | `torch.zeros()`         | Cria um tensor preenchido com zeros.                                                                       | `b = torch.zeros(3, 3)`                                                            |
|                            | `torch.ones()`          | Cria um tensor preenchido com uns.                                                                         | `c = torch.ones(3, 3)`                                                             |
|                            | `torch.arange()`        | Cria um tensor com valores em um intervalo específico, semelhante ao `range()` do Python.                  | `d = torch.arange(0, 10)`                                                          |
|                            | `torch.reshape()`       | Altera a forma (shape) de um tensor sem alterar seus dados.                                                | `e = d.reshape(2, 5)`                                                              |
|                            | `torch.cat()`           | Concatena uma sequência de tensores ao longo de uma dimensão específica.                                   | `f = torch.cat((tensor1, tensor2), dim=0)`                                         |
|                            | `torch.stack()`         | Empilha uma sequência de tensores ao longo de uma nova dimensão.                                           | `g = torch.stack((tensor1, tensor2))`                                              |
| **Operações Matemáticas**   | `torch.add()`           | Soma dois tensores, elemento a elemento.                                                                   | `h = torch.add(a, b)`                                                              |
|                            | `torch.sub()`           | Subtrai um tensor de outro, elemento a elemento.                                                           | `i = torch.sub(a, b)`                                                              |
|                            | `torch.mul()`           | Multiplica dois tensores, elemento a elemento.                                                             | `j = torch.mul(a, b)`                                                              |
|                            | `torch.div()`           | Divide um tensor por outro, elemento a elemento.                                                           | `k = torch.div(a, b)`                                                              |
|                            | `torch.mm()`            | Realiza multiplicação matricial entre dois tensores.                                                       | `l = torch.mm(matrix1, matrix2)`                                                   |
|                            | `torch.sum()`           | Calcula a soma dos elementos de um tensor ao longo de uma dimensão especificada.                           | `m = torch.sum(tensor, dim=0)`                                                     |
|                            | `torch.mean()`          | Calcula a média dos elementos de um tensor ao longo de uma dimensão especificada.                          | `n = torch.mean(tensor, dim=0)`                                                    |
| **Gradientes e Autograd**   | `torch.autograd`        | Pacote de diferenciação automática para cálculo de gradientes.                                             | `from torch.autograd import Variable`                                              |
|                            | `Variable()`            | Envolve um tensor para habilitar o cálculo automático de gradientes.                                       | `x = Variable(torch.tensor([1, 2, 3]), requires_grad=True)`                        |
|                            | `backward()`            | Calcula o gradiente da função com relação às variáveis independentes.                                      | `loss.backward()`                                                                  |
|                            | `with torch.no_grad()`  | Bloqueia o cálculo de gradientes, útil para inferência e otimização de memória.                            | `with torch.no_grad():`<br>`output = model(input)`                                 |
| **Construção de Modelos**   | `torch.nn.Module`       | Classe base para todos os modelos de PyTorch, utilizada para construir redes neurais personalizadas.       | `class MyModel(nn.Module):`<br>`def __init__(self): ...`                           |
|                            | `forward()`             | Método que define a passagem para frente (forward pass) dos dados através do modelo.                       | `def forward(self, x): return x`                                                   |
|                            | `torch.nn.Sequential()` | Cria um modelo sequencial empilhando camadas em ordem.                                                     | `model = nn.Sequential(nn.Linear(10, 20), nn.ReLU())`                              |
| **Camadas**                 | `torch.nn.Linear()`     | Cria uma camada totalmente conectada (fully connected).                                                    | `nn.Linear(10, 20)`                                                                |
|                            | `torch.nn.Conv2d()`     | Cria uma camada convolucional 2D, usada em redes neurais convolucionais (CNNs).                            | `nn.Conv2d(in_channels=1, out_channels=32, kernel_size=3)`                         |
|                            | `torch.nn.MaxPool2d()`  | Adiciona uma camada de pooling máximo, usada em CNNs para reduzir a dimensionalidade.                      | `nn.MaxPool2d(kernel_size=2, stride=2)`                                            |
|                            | `torch.nn.Dropout()`    | Aplica regularização Dropout para prevenir overfitting.                                                    | `nn.Dropout(p=0.5)`                                                                |
|                            | `torch.nn.LSTM()`       | Cria uma camada LSTM (Long Short-Term Memory), usada em modelos de séries temporais e processamento de linguagem natural. | `nn.LSTM(input_size=10, hidden_size=20, num_layers=2)`                      |
|                            | `torch.nn.Embedding()`  | Cria uma camada de embedding, usada para mapeamento de palavras ou itens categóricos em vetores de baixa dimensão. | `nn.Embedding(num_embeddings=1000, embedding_dim=64)`                        |
| **Funções de Perda**        | `torch.nn.MSELoss()`    | Calcula o erro quadrático médio, usado frequentemente em regressão.                                        | `criterion = nn.MSELoss()`                                                         |
|                            | `torch.nn.CrossEntropyLoss()` | Calcula a entropia cruzada categórica, comum em tarefas de classificação.                                | `criterion = nn.CrossEntropyLoss()`                                                |
|                            | `torch.nn.BCELoss()`    | Calcula a perda de entropia cruzada binária, usada em tarefas de classificação binária.                    | `criterion = nn.BCELoss()`                                                         |
| **Otimização**              | `torch.optim.SGD()`     | Implementa o otimizador Stochastic Gradient Descent (SGD).                                                  | `optimizer = torch.optim.SGD(model.parameters(), lr=0.01)`                         |
|                            | `torch.optim.Adam()`    | Implementa o otimizador Adam, amplamente usado em deep learning.                                            | `optimizer = torch.optim.Adam(model.parameters(), lr=0.001)`                       |
|                            | `step()`                | Atualiza os parâmetros do modelo com base nos gradientes calculados.                                        | `optimizer.step()`                                                                 |
|                            | `zero_grad()`           | Zera os gradientes dos parâmetros do modelo antes de uma nova atualização.                                  | `optimizer.zero_grad()`                                                            |
| **DataLoader e Datasets**   | `torch.utils.data.DataLoader()` | Cria um iterador para carregar dados em minibatches, permitindo operações de embaralhamento e multithreading. | `dataloader = torch.utils.data.DataLoader(dataset, batch_size=32, shuffle=True)` |
|                            | `torch.utils.data.Dataset()` | Classe base para todos os datasets customizados, permite implementar a lógica de carregamento de dados.   | `class MyDataset(torch.utils.data.Dataset): ...`                                   |
|                            | `__getitem__()`         | Método necessário para acessar um item específico no dataset customizado.                                   | `def __getitem__(self, idx): ...`                                                  |
| **Transfer Learning**       | `torchvision.models`    | Conjunto de modelos pré-treinados disponíveis para transferência de aprendizado (ex: ResNet, VGG).          | `model = torchvision.models.resnet50(pretrained=True)`                             |
| **Salvamento/Carregamento** | `torch.save()`          | Salva o modelo ou tensor em disco.                                                                          | `torch.save(model.state_dict(), 'model.pth')`                                      |
|                            | `torch.load()`          | Carrega o modelo ou tensor salvo anteriormente.                                                             | `model.load_state_dict(torch.load('model.pth'))`                                   |
|                            | `state_dict()`          | Retorna um dicionário com os parâmetros do modelo, usado para salvar e carregar modelos.                    | `state_dict = model.state_dict()`                                                  |
| **Processamento de Imagens** | `torchvision.transforms` | Conjunto de transformações para pré-processamento de imagens, como redimensionamento, normalização e rotação. | `transform = torchvision.transforms.Compose([torchvision.transforms.Resize(256), ...])` |

Essa tabela resume as funcionalidades essenciais da **PyTorch**, que é uma biblioteca poderosa e flexível para pesquisa e desenvolvimento em aprendizado profundo e machine learning. PyTorch é conhecido por sua facilidade de uso e por permitir a definição dinâmica de gráficos computacionais, o que facilita a construção de modelos customizados e complexos.
